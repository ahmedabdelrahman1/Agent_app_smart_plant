import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:flutter/foundation.dart';
import 'package:intl/intl.dart';

class SensorData {
  final DateTime timestamp;
  final double temperature;
  final double humidity;
  final double soilMoisture;
  final double lightLevel;

  SensorData({
    required this.timestamp,
    required this.temperature,
    required this.humidity,
    required this.soilMoisture,
    required this.lightLevel,
  });

  factory SensorData.fromJson(Map<String, dynamic> json) {
    return SensorData(
      timestamp: DateTime.parse(json['inserted_at']), // Changed from 'timestamp' to 'inserted_at'
      temperature: json['temperature']?.toDouble() ?? 0.0,
      humidity: json['humidity']?.toDouble() ?? 0.0,
      soilMoisture: json['soil_moisture']?.toDouble() ?? 0.0, // Converting int to double
      lightLevel: json['light_level']?.toDouble() ?? 0.0,     // Converting int to double
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'temperature': temperature,
      'humidity': humidity,
      'soil_moisture': soilMoisture.toInt(), // Convert to int for database
      'light_level': lightLevel.toInt(),     // Convert to int for database
      // 'inserted_at' is auto-generated by the database, don't include it
    };
  }
}

class SensorService {
  static const String _baseUrl = 'https://kwpruamypgndlsbhbtlx.supabase.co/rest/v1';
  static const String _apiKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imt3cHJ1YW15cGduZGxzYmhidGx4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDgzNTA2NzEsImV4cCI6MjA2MzkyNjY3MX0.4hLP0_X-ZJzM1hkvNmYMwwmAfEg-LjnxX-E0Gq9de30';
  
  static Future<List<SensorData>> fetchLatestSensorData() async {
    try {
      final response = await http.get(
        Uri.parse('$_baseUrl/sensor_data?order=inserted_at.desc&limit=10'), // Changed to inserted_at
        headers: {
          'apikey': _apiKey,
          'Content-Type': 'application/json',
        },
      ).timeout(const Duration(seconds: 10));

      if (response.statusCode == 200) {
        final List<dynamic> data = json.decode(response.body);
        if (data.isNotEmpty) {
          return data.map((item) => SensorData.fromJson(item)).toList();
        }
      }
      
      // If we reach here, something went wrong with the API call
      debugPrint('Error fetching sensor data: ${response.statusCode} - ${response.body}');
      return _getMockLatestSensorData();
    } catch (e) {
      debugPrint('Exception fetching sensor data: $e');
      return _getMockLatestSensorData();
    }
  }

  static Future<List<SensorData>> fetchSensorDataByDateRange(
      DateTime startDate, DateTime endDate) async {
    try {
      // Format dates to ISO string format
      final formattedStartDate = startDate.toUtc().toIso8601String();
      final formattedEndDate = endDate.toUtc().toIso8601String();

      final response = await http.get(
        Uri.parse(
            '$_baseUrl/sensor_data?inserted_at=gte.$formattedStartDate&inserted_at=lte.$formattedEndDate&order=inserted_at.asc'), // Changed to inserted_at
        headers: {
          'apikey': _apiKey,
          'Content-Type': 'application/json',
        },
      ).timeout(const Duration(seconds: 15));

      if (response.statusCode == 200) {
        final List<dynamic> data = json.decode(response.body);
        return data.map((item) => SensorData.fromJson(item)).toList();
      }
      
      // If we reach here, something went wrong with the API call
      debugPrint('Error fetching historical data: ${response.statusCode} - ${response.body}');
      return _getMockHistoricalData(startDate, endDate);
    } catch (e) {
      debugPrint('Exception fetching historical data: $e');
      return _getMockHistoricalData(startDate, endDate);
    }
  }

  // Mock data for testing or when API fails
  static List<SensorData> _getMockLatestSensorData() {
    return [
      SensorData(
        timestamp: DateTime.now(),
        temperature: 24.5,
        humidity: 65.0,
        soilMoisture: 43.2,
        lightLevel: 780.0,
      ),
    ];
  }

  static List<SensorData> _getMockHistoricalData(DateTime startDate, DateTime endDate) {
    final List<SensorData> mockData = [];
    final random = DateTime.now().millisecond; // Seed for pseudo-randomness
    
    // Calculate number of days between dates
    final difference = endDate.difference(startDate).inDays;
    
    // Generate daily data points
    for (int i = 0; i <= difference; i++) {
      final currentDate = startDate.add(Duration(days: i));
      
      // Generate multiple readings per day
      for (int hour = 8; hour < 20; hour += 4) {
        final currentDateTime = DateTime(
          currentDate.year, 
          currentDate.month, 
          currentDate.day,
          hour,
        );
        
        // Use the day and hour to create semi-realistic variations
        final dayFactor = i / (difference > 0 ? difference : 1);
        final hourFactor = hour / 24.0;
        final randomFactor = (random + i + hour) % 10 / 10;
        
        mockData.add(SensorData(
          timestamp: currentDateTime,
          temperature: 20.0 + (5.0 * dayFactor) + (3.0 * hourFactor) + randomFactor,
          humidity: 50.0 + (20.0 * (1 - dayFactor)) + (10.0 * hourFactor) + randomFactor,
          soilMoisture: 40.0 - (10.0 * dayFactor) + randomFactor,
          lightLevel: 200.0 + (800.0 * hourFactor) + (random % 100),
        ));
      }
    }
    
    return mockData;
  }

  // Additional method to post sensor data (for IoT devices)
  static Future<bool> postSensorData(SensorData data) async {
    try {
      final response = await http.post(
        Uri.parse('$_baseUrl/sensor_data'),
        headers: {
          'apikey': _apiKey,
          'Content-Type': 'application/json',
          'Prefer': 'return=minimal',
        },
        body: json.encode(data.toJson()),
      ).timeout(const Duration(seconds: 10));

      if (response.statusCode == 201) {
        debugPrint('Sensor data posted successfully');
        return true;
      } else {
        debugPrint('Failed to post sensor data: ${response.statusCode}');
        return false;
      }
    } catch (e) {
      debugPrint('Exception posting sensor data: $e');
      return false;
    }
  }

  // Method to fetch sensor data statistics for a given period
  static Future<Map<String, dynamic>> fetchSensorStatistics(
      DateTime startDate, DateTime endDate) async {
    final data = await fetchSensorDataByDateRange(startDate, endDate);
    
    if (data.isEmpty) {
      return {
        'temperature': {'min': 0, 'max': 0, 'avg': 0},
        'humidity': {'min': 0, 'max': 0, 'avg': 0},
        'soilMoisture': {'min': 0, 'max': 0, 'avg': 0},
        'lightLevel': {'min': 0, 'max': 0, 'avg': 0},
      };
    }

    // Calculate statistics for each sensor type
    return {
      'temperature': _calculateStats(data.map((d) => d.temperature).toList()),
      'humidity': _calculateStats(data.map((d) => d.humidity).toList()),
      'soilMoisture': _calculateStats(data.map((d) => d.soilMoisture).toList()),
      'lightLevel': _calculateStats(data.map((d) => d.lightLevel).toList()),
    };
  }

  static Map<String, double> _calculateStats(List<double> values) {
    if (values.isEmpty) {
      return {'min': 0, 'max': 0, 'avg': 0};
    }
    
    final min = values.reduce((a, b) => a < b ? a : b);
    final max = values.reduce((a, b) => a > b ? a : b);
    final avg = values.reduce((a, b) => a + b) / values.length;
    
    return {'min': min, 'max': max, 'avg': avg};
  }
}